---
title: Create index from Microsoft Academic Graph(MAG)
description: Step-by-step guide for generating MAKES indexes from a MAG release.
ms.topic: tutorial
ms.date: 0
---

# Generating MAKES indexes from a MAG release

 Step-by-step guide for generating MAKES indexes from a Microsoft Academic Graph(MAG) release. For more information on obtaining a MAG release, visit [Get Microsoft Academic Graph on Azure storage](../graph/get-started-setup-provisioning.md).  In this example we will be building a custom index of all Microsoft publications and associated entities.

## Prerequisites

- Microsoft Academic Graph(MAG) release
- Microsoft Academic Knowledge Exploration Service(MAKES) release
- Azure subscription

## Generating MAKES entities using USQL

MAKES indexes are generated from specifically formatted MAG data.  In order to create a new index, you will need to generate the entities you would like in the index from MAG.  We will start by running a USQL script on your MAG subscription to generate the data required to build the custom index.  To do this, you will need to go to your Azure Data Lake Analytics (ADLA) service instance and submit a new ALDA job to generate the text files containing academic data.

1. In the Azure portal, go to the Azure Data Lake Analytics (ADLA) service that you create and select **Overview > New Job**.

1. Copy and past the following code block in the script window.

```U-SQL
// Enables OUTPUT statements to generate dynamic files using column values
SET @@FeaturePreviews = "DataPartitionedOutput:on";

// The Azure blob storage account name that contains the Microsoft Academic Graph data to be used by this script
DECLARE @inputBlobAccount string = "<MagAzureStorageAccount>";

// The Azure blob storage container name that contains the Microsoft Academic Graph data to be used by this script
DECLARE @inputBlobContainer string = "<MagContainer>";

// The Windows Azure Blob Storage (WASB) URI of the Microsoft Academic Graph data to be used by this script
DECLARE @inputUri string = "wasb://" + @inputBlobContainer + "@" + @inputBlobAccount + "/";

// The Azure blob storage account name that output files will be generated in
DECLARE @outputBlobAccount string = "<OutputAzureStorageAccount>";

// The Azure blob storage container name that output files will be generated in
// ***IMPORTANT: This container must exist before running this script otherwise the script will fail
DECLARE @outputBlobContainer string = "<OutputContainer>";

// The Windows Azure Blob Storage (WASB) URI  that output files will be generated in
DECLARE @outputUri = "wasb://" + @outputBlobContainer + "@" + @outputBlobAccount + "/azure-search-data/{FileNumber}-data.{IndexerNumber}";

// The number of Azure Search indexers that will be used when indexing the documents generated by this script
DECLARE @maximumIndexerCount int = 1;

// The the number of files to generate for each indexer
DECLARE @maximumFileCountPerIndexer int = 10;

// The affiliation that should be used to filter the results returned by this script
// To target a custom affiliation, find its normalized name and enter it below
DECLARE @affiliationNormalizedNameFilter string = "microsoft";

//
// Load academic data
//
@papers = Papers(@inputUri);

@paperAuthorAffiliations = PaperAuthorAffiliations(@inputUri);

@authors = Authors(@inputUri);

@affiliations = Affiliations(@inputUri);

@paperFieldsOfStudy = PaperFieldsOfStudy(@inputUri);

@fieldsOfStudy = FieldsOfStudy(@inputUri);

//
// Generate non-null values for optional fields to ensure we can properly join
//
@papers =
    SELECT *,
           (JournalId == null? (long) - 1 : JournalId.Value) AS JId,
           (ConferenceSeriesId == null? (long) - 1 : ConferenceSeriesId.Value) AS CId
    FROM @papers;

@paperAuthorAffiliations =
    SELECT *,
           (AffiliationId == null? (long) - 1 : AffiliationId.Value) AS AfId
    FROM @paperAuthorAffiliations;

//
// Filter academic data to only include patents published in affiliation with Microsoft
//
@papers =
    SELECT DISTINCT P.*
    FROM @papers AS P
         INNER JOIN
             @paperAuthorAffiliations AS Paa
         ON P.PaperId == Paa.PaperId
         INNER JOIN
             @affiliations AS A
         ON Paa.AfId == A.AffiliationId
    WHERE A.NormalizedName == @affiliationNormalizedNameFilter AND P.DocType == "Patent";

//
// Filter and flatten paper author data into a single attribute for each paper
//
@paperAuthorsDistinct =
    SELECT DISTINCT A.PaperId,
                    A.AuthorId,

                    // NOTE: Casting AuthorSequenceNumber to nullable as MAP_AGG requires it
                    ((uint?)A.AuthorSequenceNumber) AS AuthorSequenceNumber
    FROM @paperAuthorAffiliations AS A
    INNER JOIN @papers AS P
        ON A.PaperId == P.PaperId;

@paperAuthors =
    SELECT P.PaperId,
           A.NormalizedName AS AuthorName,
           P.AuthorSequenceNumber
    FROM @paperAuthorsDistinct AS P
         INNER JOIN
             @authors AS A
         ON P.AuthorId == A.AuthorId;

@paperAuthorsAggregated =
    SELECT PaperId,
           "[" + string.Join(",", MAP_AGG("\"" + AuthorName + "\"", AuthorSequenceNumber).OrderBy(a => a.Value).Select(a => a.Key)) + "]" AS Authors
    FROM @paperAuthors
    GROUP BY PaperId;

//
// Filter and flatten paper field of study data into a single attribute for each paper
//
@paperFieldsOfStudy =
    SELECT DISTINCT A.PaperId,
                    A.FieldOfStudyId
    FROM @paperFieldsOfStudy AS A
    INNER JOIN @papers AS P
        ON A.PaperId == P.PaperId;

@paperFieldsOfStudy =
    SELECT P.PaperId,
           F.NormalizedName AS FieldOfStudyName
    FROM @paperFieldsOfStudy AS P
         INNER JOIN
             @fieldsOfStudy AS F
         ON P.FieldOfStudyId == F.FieldOfStudyId;

@paperFieldsOfStudyAggregated =
    SELECT PaperId,
           "[" + string.Join(",", ARRAY_AGG("\"" + FieldOfStudyName + "\"")) + "]" AS FieldsOfStudy
    FROM @paperFieldsOfStudy
    GROUP BY PaperId;

//
// Generate tab delimited files containing the partitioned academic data we filtered/flattened above
//
@paperDocumentFields =
    SELECT P.PaperId,
           P.Rank,
           P.EstimatedCitation,
           P.Year,
           A.Authors,
           P.PaperTitle,
           F.FieldsOfStudy,
           (int) (P.PaperId % @maximumIndexerCount) AS IndexerNumber,
           (int) (P.PaperId % @maximumFileCountPerIndexer) AS FileNumber
    FROM @papers AS P
         LEFT OUTER JOIN
             @paperAuthorsAggregated AS A
         ON P.PaperId == A.PaperId
         LEFT OUTER JOIN
             @paperFieldsOfStudyAggregated AS F
         ON P.PaperId == F.PaperId;

//
// Generates partitioned files based on the values in the ForIndexerNumber and PartitionNumber columns
//
OUTPUT @paperDocumentFields
TO @outputUri
USING Outputters.Tsv(quoting : false);
```

1. Replace placeholder values in the script using the table below

   |Value  |Description  |
   |---------|---------|
   |**`<MagAzureStorageAccount>`** | The name of your Azure Storage account containing the Microsoft Academic Graph data set. |
   |**`<MagContainer>`** | The container name in your Azure Storage account containing the Microsoft Academic graph data set, usually in the form of **mag-yyyy-mm-dd**. |
   |**`<OutputAzureStorageAccount>`** | The name of your Azure Storage account where you'd like the text documents to go. |
   |**`<OutputContainer>`** | The container name in your Azure Storage account where you'd like the text documents to go. |

    > [!TIP]
    > This tutorial uses Microsoft as an organization by default. You can target any organization by finding its NormalizedName in the Microsoft Academic Graph and then changing the value of the affiliationNormalizedNameFilter variable to said name.
    >
    > Please note that doing this may impact time estimates for script execution and index generation later on in this tutorial.

1. Provide a **Job name**, change **AUs** to 50, and select **Submit**

   ![Submit GenerateAzureSearchData job](../graph/media/tutorial-search-submit-usql.png)

1. The job should finish successfully in about 5 minutes

   ![GenerateAzureSearchData job status](../graph/media/tutorial-search-usql-status.png)


## Build index using MAKES command line tool

Now that the data has been generated to build your index, we need to create some resources that the index will use and build the index using the kesm.exe tool.

### Create indexing resources

If you have not done so already, download the kesm.exe tool from your MAKES subscription.  See the [Create an API Instance](get-started-create-api-instances.md) for instructions on downloading the tool.

1. Open a command prompt or terminal window and navigate to the folder where you have extracted the kesm.exe tool.

1. Copy the following command to your command / terminal window:

```cmd

kesm CreateIndexResources --IndexResourceName <IndexResourceName> --MakesPackage <MakesPackageLocation> --MakesIndexResourceConfigFilePath <MakesIndexResourceConfigFilePath>

```

1. Replace the default values with the values from the table below:

| Values | Description |
|---------|---------|
|**`<IndexResourceName>`** | The name of the indexing resources you created above |
|**`<MakesPackageLocation>`** | The location of the MAKES package that you created above |
|**`<MakesIndexResourceConfigFilePath>`** | The file path and name of the file that will hold the configuration information to build your index |

### Submit index build job

The final step to generate your index is to submit a job to ADLA via the kesm tool.  The kesm tool uses Azure resources to generate index and when finished will place the new index in your storage account to deploy.

> [!IMPORTANT]
    > Generating indexes can cost money.
    >
    > Time to create an index can be up to 3 hours.

## Next steps

Now that you have successfullly generated an index, you can deploy this index to a new or existing MAKES deployment.  See [Create an API instance](get-started-create-api-instances.md).
